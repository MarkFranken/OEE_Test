<!doctype html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Machine Timeline Dashboard</title>
    <style>
      :root {
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: #18212f;
        background: #eef2f7;
      }
      body { margin: 0; }
      .container { width: 100%; max-width: none; margin: 0; padding: 1rem 1rem 2rem; box-sizing: border-box; }
      h1,h2,h3 { margin-top: 0; }
      .panel { background: #fff; border-radius: 14px; padding: 1rem; margin-top: 1rem; box-shadow: 0 2px 10px rgba(20,35,59,0.08); }
      .uploader { display: grid; gap: .75rem; }
      .button { border: none; background: #1768ff; color: #fff; border-radius: 8px; padding: .65rem .9rem; font-weight: 600; cursor: pointer; width: fit-content; }
      .button.secondary { background: #425466; }
      #fileInput { display: none; }
      .status,.muted { color: #4f6478; margin: 0; }
      .loaded-files { margin: 0; padding-left: 1rem; }
      .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: .75rem; }
      .card { background: #f5f8fe; border: 1px solid #dbe4f1; border-radius: 10px; padding: .8rem; }
      .card strong { display: block; margin-top: .3rem; font-size: 1.1rem; }
      .table-wrapper { overflow-x: auto; }
      table { width: 100%; border-collapse: collapse; }
      th,td { text-align: left; border-bottom: 1px solid #e5eaf2; padding: .55rem; vertical-align: top; }
      .progress { width: 100%; height: 12px; background: #eff3f9; border-radius: 999px; overflow: hidden; }
      .progress > span { display: block; height: 100%; background: linear-gradient(90deg,#2a7bff,#23c29f); }
      .stacked-progress { display:flex; width:100%; height:12px; background:#eff3f9; border-radius:999px; overflow:hidden; }
      .stacked-progress .seg { height:100%; }
      .seg.up { background:#22a06b; }
      .seg.ready { background:#f6c547; }
      .seg.other { background:#e34b4b; }
      .reason-row { display:grid; grid-template-columns: 1fr 80px; align-items: center; gap:.75rem; margin-bottom:.5rem; }
      .reason-row.clickable { cursor:pointer; padding:.35rem; border-radius:8px; border:1px solid transparent; }
      .reason-row.clickable.active-reason { background:#eef5ff; border-color:#cfe1ff; }
      .cross-layout { display:grid; grid-template-columns:minmax(0,1fr) 380px; gap:1rem; }
      @media (max-width: 1100px) { .cross-layout { grid-template-columns:1fr; } }
      #jobSelect { margin: .5rem 0 1rem; padding: .5rem; }
      .meta { display:flex; flex-wrap:wrap; gap:.5rem; }
      .pill { padding:.2rem .55rem; border-radius:999px; background:#eaf1ff; color:#275299; font-size:.8rem; font-weight:600; }
      .tip { margin:0; font-size:.92rem; color:#4a5f74; }
      .table-controls { display:flex; flex-wrap:wrap; gap:.6rem; margin:.4rem 0 .8rem; align-items:end; }
      .field { display:grid; gap:.2rem; }
      .field label { font-size:.82rem; color:#4f6478; }
      .field input,.field select { padding:.45rem .5rem; border:1px solid #cfd9e6; border-radius:8px; min-width:180px; }
      .jobs-layout { display:grid; grid-template-columns: minmax(0, 1fr) 360px; gap:1rem; }
      .job-detail { border:1px solid #dbe4f1; border-radius:12px; padding:.9rem; background:#f9fbff; position:sticky; top:1rem; align-self:start; max-height:calc(100vh - 2rem); overflow:auto; }
      @media (max-width: 1280px) { .jobs-layout { grid-template-columns: minmax(0, 1fr) 320px; } .downtime-layout { grid-template-columns: minmax(0, 1fr) 320px; } }
      @media (max-width: 1100px) { .jobs-layout { grid-template-columns: 1fr; } .downtime-layout { grid-template-columns: 1fr; } .job-detail { position:static; max-height:none; } }
      @media (max-width: 768px) { .container { padding: .75rem .5rem 1.25rem; } .table-controls { gap:.45rem; } .field input,.field select { min-width: 150px; } }
      .job-detail h3 { margin-bottom:.5rem; }
      .job-detail canvas { width:100%; max-width:220px; display:block; margin:.3rem auto .8rem; }
      .legend { display:grid; gap:.35rem; margin-bottom:.8rem; }
      .legend-item { display:flex; align-items:center; justify-content:space-between; gap:.6rem; font-size:.9rem; }
      .dot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:.35rem; }
      .jobs-table tbody tr { cursor:pointer; }
      .jobs-table tbody tr.active-row { background:#eef5ff; }
      .downtime-list { margin:0; padding-left:1rem; display:grid; gap:.25rem; }
      .downtime-layout { display:grid; grid-template-columns: minmax(0, 1fr) 380px; gap:1rem; }
      .downtime-events { margin:0; padding-left:1rem; display:grid; gap:.35rem; }
      .downtime-events li { line-height:1.35; }
      .downtime-table tbody tr { cursor:pointer; }
      .downtime-table tbody tr.active-row { background:#eef5ff; }
      .tabs { display:flex; gap:.5rem; margin-top:1rem; }
      .tab-btn { border:1px solid #cfd9e6; background:#fff; color:#1f3552; border-radius:10px; padding:.5rem .8rem; cursor:pointer; font-weight:600; }
      .tab-btn.active { background:#1768ff; color:#fff; border-color:#1768ff; }
      .tab-content { margin-top:.75rem; }
      .tab-pane.hidden { display:none; }

    </style>
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Machine Timeline Dashboard</h1>
        <p>Laad zowel <code>Timeline CSV</code> als <code>JobStatistics CSV</code> in. Dubbele bestanden worden automatisch geweigerd.</p>
      </header>

      <div class="tabs" role="tablist" aria-label="Dashboard tabs">
        <button id="tabImportBtn" class="tab-btn active" type="button" role="tab" aria-selected="true">Importeren</button>
        <button id="tabOverviewBtn" class="tab-btn" type="button" role="tab" aria-selected="false">Overzicht</button>
        <button id="tabDowntimeBtn" class="tab-btn" type="button" role="tab" aria-selected="false">Downtime redenen</button>
      </div>

      <div class="tab-content">
        <section id="importTab" class="tab-pane">
          <section class="panel uploader">
            <h2>Bestanden importeren</h2>
            <label for="fileInput" class="button">Kies CSV-bestand(en)</label>
            <input id="fileInput" type="file" accept=".csv,text/csv" multiple />
            <button id="clearBtn" class="button secondary" type="button">Leeg dataset</button>
            <p class="tip">Je kunt deze pagina direct openen via dubbelklik op <code>index.html</code>.</p>
            <p id="status" class="status">Nog geen bestanden geladen.</p>
            <div id="fileTypeInfo" class="meta"></div>
            <ul id="loadedFiles" class="loaded-files"></ul>
          </section>
        </section>

        <section id="overviewTab" class="tab-pane hidden">
          <section class="panel">
            <h2>Overzicht</h2>
            <div id="summaryCards" class="cards"></div>
          </section>

          <section class="panel">
            <h2>Efficiëntie per job</h2>
        <div class="table-controls">
          <div class="field">
            <label for="jobFilterInput">Filter op jobnaam of downtime reden</label>
            <input id="jobFilterInput" type="text" placeholder="bijv. 42834 of ReadyNoProductFeed" />
          </div>
          <div class="field">
            <label for="sortBySelect">Sorteer op</label>
            <select id="sortBySelect">
              <option value="date_desc">Datum (nieuwste eerst)</option>
              <option value="date_asc">Datum (oudste eerst)</option>
              <option value="job_asc">Jobnaam (A-Z)</option>
              <option value="job_desc">Jobnaam (Z-A)</option>
              <option value="eff_desc">Efficiëntie hoog-laag</option>
              <option value="eff_asc">Efficiëntie laag-hoog</option>
              <option value="pieces_desc">Total Pieces hoog-laag</option>
              <option value="pieces_asc">Total Pieces laag-hoog</option>
              <option value="speed_desc">Snelheid uptime hoog-laag</option>
              <option value="speed_asc">Snelheid uptime laag-hoog</option>
            </select>
          </div>
        </div>
        <div class="jobs-layout">
          <div class="table-wrapper">
            <table class="jobs-table">
              <thead>
                <tr>
                  <th>Job</th>
                  <th>Periode</th>
                  <th>Uptime (JobStatistics primair)</th>
                  <th>Downtime (JobStatistics primair)</th>
                  <th>Efficiëntie (JobStatistics primair)</th>
                  <th>Total Pieces</th>
                  <th>Good/Reject</th>
                  <th>Production Rate</th>
                  <th>Snelheid tijdens uptime (good/uur)</th>
                  <th>Belangrijkste overige downtime oorzaak</th>
                </tr>
              </thead>
              <tbody id="jobTableBody"></tbody>
            </table>
          </div>
          <aside class="job-detail" id="jobDetailPanel">
            <h3>Job detail</h3>
            <p id="jobDetailTitle" class="muted">Klik op een job in de tabel.</p>
            <canvas id="jobPieChart" width="220" height="220" aria-label="Job verdeling chart"></canvas>
            <div id="jobPieLegend" class="legend"></div>
            <h4>Downtimes in deze job</h4>
            <ul id="jobDowntimeList" class="downtime-list"></ul>
          </aside>
        </div>
      </section>

          <section class="panel">
            <h2>Dwarsdoorsnede per job</h2>
            <label for="jobSelect">Selecteer job:</label>
            <select id="jobSelect"></select>
            <div id="selectedJobStats"></div>
            <h3>Downtime oorzaken (timeline)</h3>
            <div class="cross-layout">
              <div id="reasonBreakdown"></div>
              <aside class="job-detail" id="crossReasonDetailPanel">
                <h3>Events van downtime-reden</h3>
                <p id="crossReasonTitle" class="muted">Klik op een downtime oorzaak in de lijst.</p>
                <ul id="crossReasonEvents" class="downtime-events"></ul>
              </aside>
            </div>
          </section>
        </section>

        <section id="downtimeTab" class="tab-pane hidden">
          <section class="panel">
            <h2>Totale downtime per reden</h2>
            <div class="downtime-layout">
              <div class="table-wrapper">
                <table class="downtime-table">
                  <thead>
                    <tr>
                      <th>Downtime reden</th>
                      <th>Totale downtime</th>
                      <th>Aandeel</th>
                    </tr>
                  </thead>
                  <tbody id="downtimeReasonTableBody"></tbody>
                </table>
              </div>
              <aside class="job-detail" id="downtimeReasonDetailPanel">
                <h3>Detail downtime reden</h3>
                <p id="downtimeReasonTitle" class="muted">Klik op een downtime reden in de tabel.</p>
                <ul id="downtimeReasonEvents" class="downtime-events"></ul>
              </aside>
            </div>
          </section>
        </section>
      </div>
    </main>

    <script>
      const els = {
        fileInput: document.getElementById('fileInput'),
        clearBtn: document.getElementById('clearBtn'),
        status: document.getElementById('status'),
        fileTypeInfo: document.getElementById('fileTypeInfo'),
        loadedFiles: document.getElementById('loadedFiles'),
        summaryCards: document.getElementById('summaryCards'),
        jobTableBody: document.getElementById('jobTableBody'),
        jobSelect: document.getElementById('jobSelect'),
        selectedJobStats: document.getElementById('selectedJobStats'),
        reasonBreakdown: document.getElementById('reasonBreakdown'),
        crossReasonTitle: document.getElementById('crossReasonTitle'),
        crossReasonEvents: document.getElementById('crossReasonEvents'),
        jobFilterInput: document.getElementById('jobFilterInput'),
        sortBySelect: document.getElementById('sortBySelect'),
        jobDetailTitle: document.getElementById('jobDetailTitle'),
        jobPieChart: document.getElementById('jobPieChart'),
        jobPieLegend: document.getElementById('jobPieLegend'),
        jobDowntimeList: document.getElementById('jobDowntimeList'),
        tabImportBtn: document.getElementById('tabImportBtn'),
        tabOverviewBtn: document.getElementById('tabOverviewBtn'),
        tabDowntimeBtn: document.getElementById('tabDowntimeBtn'),
        importTab: document.getElementById('importTab'),
        overviewTab: document.getElementById('overviewTab'),
        downtimeTab: document.getElementById('downtimeTab'),
        downtimeReasonTableBody: document.getElementById('downtimeReasonTableBody'),
        downtimeReasonTitle: document.getElementById('downtimeReasonTitle'),
        downtimeReasonEvents: document.getElementById('downtimeReasonEvents')
      };

      const state = {
        signatures: new Set(),
        loadedFiles: [],
        timelineEvents: [],
        jobStatisticsRows: [],
        tableFilterText: '',
        tableSortBy: 'date_desc',
        selectedJobName: '',
        activeTab: 'import',
        selectedDowntimeReason: '',
        selectedCrossReason: ''
      };

      const HEADERS = {
        timeline: 'start time,shift id,production state,reason,duration,job name',
        jobStats: 'job start time,job end time,job name,current user,additional data,total pieces,good pieces,reject pieces,bad piece rate,total time,scheduled downtime,unscheduled downtime,uptime,good production time,nominal production time,nominal production time rate,scheduled downtime rate,unscheduled downtime rate,production rate,shift name'
      };

      const ALARM_TEXT_BY_CODE = {
        0: 'Noodstop actief',
        1: 'Noodstop Vouwplak actief',
        2: 'Noodstop downstream actief',
        3: 'Geen luchtdruk',
        4: 'Niet alle servo\'s zijn geïnitialiseerd',
        10: 'Noodstop knop ingedrukt op hoofdpaneel OP1',
        11: 'Noodstop knop ingedrukt op paneel OP2',
        12: 'Noodstop knop ingedrukt op paneel OP3',
        13: 'Noodstop knop ingedrukt op paneel OP4',
        20: 'Stop knop ingedrukt',
        40: 'Robopacker draait te langzaam of vouwplak draait te snel. Pas snelheden aan.',
        60: 'Geen 24V in de kast (A4)',
        61: 'Geen 24V in het veld (A5)',
        62: 'Geen 24V CPU voeding P3 servo driver Seperator/Collector/Stacker (P1)',
        63: 'Geen 24V CPU voeding P3 servo driver Gantry (P1.1)',
        64: 'Geen 24V CPU voeding micro servo drives (M1)',
        65: 'Geen 24V geschakelde voeding (A6)',
        66: 'Geen 24V geschakelde zone 1 (Z1)',
        67: 'Geen 24V geschakelde zone 2 (Z2)',
        68: 'Geen 24V remvoeding micro servo drives (A7)',
        69: 'Geen 24V I/O kaarten in het veld (A8)',
        70: 'Geen 24V X2X bus (A3.1)',
        97: 'Kritisch alarm',
        98: 'Kritisch alarm',
        99: 'Bewegingstimeout cylinder',
        100: 'Separator breedte links beweegt niet',
        101: 'Separator breedte rechts beweegt niet',
        102: 'Robotpacker gestopt, risico op botsing. Productaanvoer te snel',
        103: 'Separatiefout, kartonstroom te lang. Systeem gestopt',
        104: 'Separator positieverzet beweegt niet',
        105: 'Wisselen van encoder mislukt',
        106: 'Dozen hoge snelheidsbanden separator verwijderen vóór starten',
        107: 'Referentie fout servo separatievinger links',
        108: 'Referentie fout servo separatievinger rechts',
        109: 'Kritisch alarm Motor: separator breedte links',
        110: 'Kritisch alarm Motor: separator breedte rechts',
        111: 'Kritisch alarm Motor: separator hoogte',
        112: 'Blokkade van dozen aan het einde van de separator',
        113: 'Kritisch alarm servo 0',
        114: 'Kritisch alarm servo 1',
        115: 'Kritisch alarm servo 2',
        116: 'Kritisch alarm servo 3',
        117: 'Kritisch alarm servo 4',
        118: 'Kritisch alarm servo 5',
        119: 'Kritisch alarm servo 6',
        120: 'Kritisch alarm servo 7',
        121: 'Kritisch alarm servo 8',
        122: 'Kritisch alarm servo 9',
        123: 'Kritisch alarm module Seperator cabinet',
        124: 'Dozen niet gesepareerd, controleer invoerriemen',
        125: 'Doosafstand te klein voor correcte separatie',
        126: 'Separatie gestart maar Collector niet klaar',
        127: 'Separator invoer hoogte meting buiten bereik',
        128: 'Motor separator hoogte beweegt verkeerde richting',
        129: 'Motor separator breedte links beweegt verkeerde richting',
        130: 'Motor separator breedte rechts beweegt verkeerde richting',
        131: 'Separatie vingers lopen niet synchroon',
        132: 'Onjuiste separatie gedetecteerd, invoer gestopt',
        150: 'Collector/Stacker breedte veranderd; automatisch leegdraaien niet mogelijk',
        151: 'Referentie fout servo Collector Pushvinger verticaal 1',
        152: 'Referentie fout servo Collector Pushvinger verticaal 2',
        153: 'Kritisch alarm Motor: Collector/Stacker breedte',
        154: 'Naar startpositie bewegen niet mogelijk met producten in machine',
        155: 'Kritisch alarm servo 10',
        156: 'Kritisch alarm servo 11',
        157: 'Kritisch alarm servo 12',
        158: 'Kritisch alarm servo 13',
        159: 'Kritisch alarm servo 14',
        160: 'Kritisch alarm servo 15',
        161: 'Kritisch alarm servo 16',
        162: 'Kritisch alarm servo 17',
        163: 'Kritisch alarm servo 18',
        164: 'Kritisch alarm servo 19',
        165: 'Kritisch alarm servo 20',
        166: 'Dozen boven achterwand Collector gedetecteerd',
        167: 'Kritisch alarm module Collector cabinet',
        168: 'Motor Collector/Stacker breedte beweegt verkeerde richting',
        169: 'Seperator heeft de Collector niet binnen de tijd kunnen vullen',
        200: 'Stacker bundel te hoog; risico op crash',
        201: 'Referentie fout servo Stacker Pushvinger verticaal 1',
        202: 'Referentie fout servo Stacker Pushvinger verticaal 2',
        213: 'Stacker kan bundel niet verder duwen, wacht op Strapper gereed',
        214: 'Stacker kan bundel niet verder duwen, wacht op Downstream gereed',
        215: 'Stacker cannot push bundle, waiting on Conveyor ready',
        216: 'Stacker crashbeveiligingssensor geactiveerd',
        217: 'Holdingfinger beweegt niet',
        221: 'Downpusher Stacker heeft producthoogte niet op tijd gedetecteerd',
        250: 'Geen luchtdruk op Gantry grijper',
        300: 'Synchronisatie van Strapper mislukt',
        302: 'Strapmateriaal op',
        305: 'Strapper storing – controleer status',
        306: 'Strapper noodstop actief',
        307: 'Strapper niet gereed om te ontvangen',
        350: 'Laserfotocel uitvoerband zone 2 te lang geblokkeerd',
        351: 'Eindfotocel uitvoerband zone 2 te lang geblokkeerd',
        352: 'Fout Interroll-motor uitvoerband zone 2',
        400: 'Geen 24V in de kast (A4)',
        401: 'Geen 24V in het veld (A5)',
        402: 'Geen 24V geschakelde zone 2 (Z2)',
        403: 'Noodstop knop ingedrukt op paneel OP5',
        404: 'Noodstop knop ingedrukt op operatorpaneel OP6',
        425: 'Servo error stopplaat transportbaan (35T3/35M6)',
        426: 'Frequentieregelaar error transportbaan (16T1/16M4)',
        427: 'Timeout stopperplaat referentie cyclus',
        428: 'Timeout stopperplaat positionerings cyclus',
        450: 'Downstream niet gereed',
        500: 'Kritisch alarm servo 35',
        501: 'Kritisch alarm servo 36',
        502: 'Kritisch alarm servo 37',
        503: 'Kritisch alarm servo 38',
        504: 'Kritisch alarm servo 39'
      };


      els.fileInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files || []);
        if (files.length === 0) return;

        let added = 0;
        let duplicates = 0;
        let unsupported = 0;

        for (const file of files) {
          const content = await file.text();
          const signature = await getSignature(content);
          if (state.signatures.has(signature)) { duplicates += 1; continue; }

          const parsed = parseCsvByType(content);
          if (parsed.type === 'unknown') { unsupported += 1; continue; }

          state.signatures.add(signature);
          state.loadedFiles.push({ name: file.name, type: parsed.type });
          if (parsed.type === 'timeline') state.timelineEvents.push(...parsed.rows);
          if (parsed.type === 'jobStats') state.jobStatisticsRows.push(...parsed.rows);
          added += 1;
        }

        event.target.value = '';
        render({ added, duplicates, unsupported });
      });

      els.clearBtn.addEventListener('click', () => {
        state.signatures.clear();
        state.loadedFiles = [];
        state.timelineEvents = [];
        state.jobStatisticsRows = [];
        render({ added: 0, duplicates: 0, unsupported: 0 });
      });

      els.jobSelect.addEventListener('change', () => {
        state.selectedJobName = els.jobSelect.value;
        render();
      });

      els.jobTableBody.addEventListener('click', (event) => {
        const row = event.target.closest('tr[data-job-name]');
        if (!row) return;
        state.selectedJobName = row.dataset.jobName;
        render();
      });

      els.jobFilterInput.addEventListener('input', (event) => {
        state.tableFilterText = (event.target.value || '').trim().toLowerCase();
        render();
      });

      els.sortBySelect.addEventListener('change', (event) => {
        state.tableSortBy = event.target.value;
        render();
      });

      els.reasonBreakdown.addEventListener('click', (event) => {
        const row = event.target.closest('[data-cross-reason]');
        if (!row) return;
        state.selectedCrossReason = row.dataset.crossReason;
        render();
      });

      els.downtimeReasonTableBody.addEventListener('click', (event) => {
        const row = event.target.closest('tr[data-reason]');
        if (!row) return;
        state.selectedDowntimeReason = row.dataset.reason;
        render();
      });

      els.tabImportBtn.addEventListener('click', () => {
        state.activeTab = 'import';
        render();
      });

      els.tabOverviewBtn.addEventListener('click', () => {
        state.activeTab = 'overview';
        render();
      });

      els.tabDowntimeBtn.addEventListener('click', () => {
        state.activeTab = 'downtime';
        render();
      });

      function splitCsvLine(line) { return line.split(','); }

      function formatDowntimeReason(reason) {
        const value = (reason || '').trim();
        const match = value.match(/^(.*?):\s*(\d+)$/);
        if (!match) {
          return value || 'Onbekend';
        }

        const [, prefix, alarmCodeText] = match;
        const alarmCode = Number(alarmCodeText);
        const alarmNl = ALARM_TEXT_BY_CODE[alarmCode];
        if (!alarmNl) {
          return `${prefix}: ${alarmCode} (alarmtekst onbekend)`;
        }

        return `${prefix}: ${alarmCode} - ${alarmNl}`;
      }


      function parseCsvByType(raw) {
        const lines = raw.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
        const normalized = lines.map((l) => l.toLowerCase());

        const timelineIdx = normalized.findIndex((l) => l.startsWith(HEADERS.timeline));
        if (timelineIdx !== -1) {
          const rows = lines.slice(timelineIdx + 1).map((line) => {
            const [startTime, shiftId, productionState, reason, duration, jobName] = splitCsvLine(line);
            return {
              startTime,
              startTimestamp: parseDateTime(startTime),
              shiftId,
              productionState,
              reason: formatDowntimeReason(reason),
              durationSeconds: durationToSeconds(duration),
              jobName,
              endTimestamp: parseDateTime(startTime) + durationToSeconds(duration) * 1000
            };
          }).filter((r) => r.jobName && r.startTime !== '1970-01-01 00:00:00');
          return { type: 'timeline', rows };
        }

        const jobIdx = normalized.findIndex((l) => l.startsWith(HEADERS.jobStats));
        if (jobIdx !== -1) {
          const rows = lines.slice(jobIdx + 1).map((line) => {
            const [jobStartTime, jobEndTime, jobName, currentUser, additionalData, totalPieces, goodPieces, rejectPieces, badPieceRate, totalTime, scheduledDowntime, unscheduledDowntime, uptime, goodProductionTime, nominalProductionTime, nominalProductionTimeRate, scheduledDowntimeRate, unscheduledDowntimeRate, productionRate, shiftName] = splitCsvLine(line);
            return {
              jobStartTime, jobEndTime, jobName,
              jobStartTimestamp: parseDateTime(jobStartTime),
              jobEndTimestamp: parseDateTime(jobEndTime),
              currentUser, additionalData,
              totalPieces: Number(totalPieces || 0),
              goodPieces: Number(goodPieces || 0),
              rejectPieces: Number(rejectPieces || 0),
              badPieceRate: Number(badPieceRate || 0),
              totalTimeSeconds: durationToSeconds(totalTime),
              scheduledDowntimeSeconds: durationToSeconds(scheduledDowntime),
              unscheduledDowntimeSeconds: durationToSeconds(unscheduledDowntime),
              uptimeSeconds: durationToSeconds(uptime),
              goodProductionTimeSeconds: durationToSeconds(goodProductionTime),
              nominalProductionTimeSeconds: durationToSeconds(nominalProductionTime),
              nominalProductionTimeRate: Number(nominalProductionTimeRate || 0),
              scheduledDowntimeRate: Number(scheduledDowntimeRate || 0),
              unscheduledDowntimeRate: Number(unscheduledDowntimeRate || 0),
              productionRate: Number(productionRate || 0),
              shiftName
            };
          }).filter((r) => r.jobName);
          return { type: 'jobStats', rows };
        }

        return { type: 'unknown', rows: [] };
      }

      async function getSignature(text) {
        const data = new TextEncoder().encode(text);
        if (window.crypto && window.crypto.subtle) {
          const digest = await window.crypto.subtle.digest('SHA-256', data);
          return Array.from(new Uint8Array(digest)).map((b) => b.toString(16).padStart(2, '0')).join('');
        }
        let hash = 0;
        for (const byte of data) hash = (hash * 31 + byte) >>> 0;
        return String(hash);
      }

      function durationToSeconds(value) {
        const parts = (value || '').split(':').map(Number);
        if (parts.length !== 3 || parts.some(Number.isNaN)) return 0;
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      }

      function formatDuration(seconds) {
        const s = Math.max(0, Math.floor(seconds || 0));
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
      }

      function parseDateTime(value) {
        if (!value) return NaN;
        const ts = new Date(value.replace(' ', 'T')).getTime();
        return Number.isFinite(ts) ? ts : NaN;
      }

      function formatDateTime(value) {
        if (!Number.isFinite(value)) return '-';
        const d = new Date(value);
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${y}-${m}-${day} ${hh}:${mm}`;
      }

      function aggregateByJob() {
        const byJob = new Map();
        const ensure = (jobName) => {
          if (!byJob.has(jobName)) {
            byJob.set(jobName, {
              jobName,
              timeline: { uptimeSeconds: 0, downtimeSeconds: 0, reasons: new Map() },
              stats: {
                totalPieces: 0, goodPieces: 0, rejectPieces: 0,
                totalTimeSeconds: 0, uptimeSeconds: 0, scheduledDowntimeSeconds: 0, unscheduledDowntimeSeconds: 0,
                productionRateWeightedSum: 0, productionRateWeight: 0, lastShiftName: ''
              },
              firstSeenTs: Infinity,
              lastSeenTs: -Infinity
            });
          }
          return byJob.get(jobName);
        };

        for (const event of state.timelineEvents) {
          const job = ensure(event.jobName);
          const isUptime = (event.productionState || '').toLowerCase() === 'uptime';
          if (isUptime) {
            job.timeline.uptimeSeconds += event.durationSeconds;
          } else {
            job.timeline.downtimeSeconds += event.durationSeconds;
            job.timeline.reasons.set(event.reason, (job.timeline.reasons.get(event.reason) || 0) + event.durationSeconds);
          }
          if (Number.isFinite(event.startTimestamp)) {
            job.firstSeenTs = Math.min(job.firstSeenTs, event.startTimestamp);
          }
          if (Number.isFinite(event.endTimestamp)) {
            job.lastSeenTs = Math.max(job.lastSeenTs, event.endTimestamp);
          }
        }

        for (const row of state.jobStatisticsRows) {
          const job = ensure(row.jobName);
          job.stats.totalPieces += row.totalPieces;
          job.stats.goodPieces += row.goodPieces;
          job.stats.rejectPieces += row.rejectPieces;
          job.stats.totalTimeSeconds += row.totalTimeSeconds;
          job.stats.uptimeSeconds += row.uptimeSeconds;
          job.stats.scheduledDowntimeSeconds += row.scheduledDowntimeSeconds;
          job.stats.unscheduledDowntimeSeconds += row.unscheduledDowntimeSeconds;
          job.stats.productionRateWeightedSum += row.productionRate * Math.max(1, row.totalTimeSeconds);
          job.stats.productionRateWeight += Math.max(1, row.totalTimeSeconds);
          job.stats.lastShiftName = row.shiftName || job.stats.lastShiftName;
          if (Number.isFinite(row.jobStartTimestamp)) {
            job.firstSeenTs = Math.min(job.firstSeenTs, row.jobStartTimestamp);
          }
          if (Number.isFinite(row.jobEndTimestamp)) {
            job.lastSeenTs = Math.max(job.lastSeenTs, row.jobEndTimestamp);
          }
        }

        return Array.from(byJob.values())
          .filter((job) => job.jobName && job.jobName.toLowerCase() !== 'base')
          .sort((a,b) => {
            if (a.lastSeenTs !== b.lastSeenTs) return b.lastSeenTs - a.lastSeenTs;
            return a.jobName.localeCompare(b.jobName);
          });
      }

      function render(meta = { added: 0, duplicates: 0, unsupported: 0 }) {
        const jobs = aggregateByJob();
        const filteredSortedJobs = getFilteredSortedJobs(jobs);

        els.loadedFiles.innerHTML = state.loadedFiles.map((f) => `<li>${f.name} <span class="pill">${f.type === 'timeline' ? 'timeline' : 'jobstats'}</span></li>`).join('');
        const timelineCount = state.loadedFiles.filter((f) => f.type === 'timeline').length;
        const statsCount = state.loadedFiles.filter((f) => f.type === 'jobStats').length;
        els.fileTypeInfo.innerHTML = `<span class="pill">Timeline bestanden: ${timelineCount}</span><span class="pill">JobStatistics bestanden: ${statsCount}</span><span class="pill">Tabel jobs: ${filteredSortedJobs.length}</span>`;

        if (state.loadedFiles.length === 0) {
          els.status.textContent = 'Nog geen bestanden geladen.';
        } else {
          els.status.textContent = `${meta.added} bestand(en) toegevoegd, ${meta.duplicates} dubbel(e) overgeslagen, ${meta.unsupported} niet-herkend.`;
        }

        renderSummary(jobs);
        const selectedFromFiltered = filteredSortedJobs.find((j) => j.jobName === state.selectedJobName)?.jobName;
        const selectedJobName = selectedFromFiltered || filteredSortedJobs[0]?.jobName || jobs[0]?.jobName || '';
        state.selectedJobName = selectedJobName;
        renderJobTable(filteredSortedJobs, selectedJobName);
        renderJobSelector(filteredSortedJobs, selectedJobName);
        renderJobSideDetail(jobs.find((j) => j.jobName === selectedJobName));
        renderCrossSection(selectedJobName);
        renderDowntimeReasonsTab(jobs);
        renderDowntimeReasonDetail(jobs);
        renderTabs();
      }

      function getPrimaryTimes(job) {
        const stats = job.stats;
        const timeline = job.timeline;

        const hasJobStats =
          stats.totalTimeSeconds > 0 ||
          stats.uptimeSeconds > 0 ||
          stats.scheduledDowntimeSeconds > 0 ||
          stats.unscheduledDowntimeSeconds > 0;

        if (hasJobStats) {
          const uptime = Math.max(0, stats.uptimeSeconds);
          const downtimeByParts = Math.max(0, stats.scheduledDowntimeSeconds + stats.unscheduledDowntimeSeconds);
          const downtimeByTotal = Math.max(0, stats.totalTimeSeconds - uptime);
          const downtime = Math.max(downtimeByParts, downtimeByTotal);
          return {
            source: 'jobstats',
            uptimeSeconds: uptime,
            downtimeSeconds: downtime
          };
        }

        return {
          source: 'timeline',
          uptimeSeconds: Math.max(0, timeline.uptimeSeconds),
          downtimeSeconds: Math.max(0, timeline.downtimeSeconds)
        };
      }

      function getEfficiencyBarSegments(job) {
        const breakdown = getDowntimeBreakdownForDetail(job);
        const total = breakdown.uptime + breakdown.readyDowntime + breakdown.otherDowntime;
        if (total <= 0) {
          return { upPct: 0, readyPct: 0, otherPct: 0 };
        }

        return {
          upPct: (breakdown.uptime / total) * 100,
          readyPct: (breakdown.readyDowntime / total) * 100,
          otherPct: (breakdown.otherDowntime / total) * 100
        };
      }

      function getGoodPerUptimeHour(job) {
        const primary = getPrimaryTimes(job);
        const uptimeHours = primary.uptimeSeconds / 3600;
        if (uptimeHours <= 0) return 0;
        return job.stats.goodPieces / uptimeHours;
      }

      function getFilteredSortedJobs(jobs) {
        const filterText = state.tableFilterText;

        const filtered = jobs.filter((job) => {
          if (!filterText) return true;
          const topReason = Array.from(job.timeline.reasons.keys()).join(' ').toLowerCase();
          return job.jobName.toLowerCase().includes(filterText) || topReason.includes(filterText);
        });

        const withMetrics = filtered.map((job) => {
          const primary = getPrimaryTimes(job);
          const efficiency =
            primary.uptimeSeconds + primary.downtimeSeconds === 0
              ? 0
              : (primary.uptimeSeconds / (primary.uptimeSeconds + primary.downtimeSeconds)) * 100;
          return { job, efficiency, pieces: job.stats.totalPieces || 0, speed: getGoodPerUptimeHour(job) };
        });

        withMetrics.sort((a, b) => {
          switch (state.tableSortBy) {
            case 'date_asc':
              return a.job.firstSeenTs - b.job.firstSeenTs;
            case 'job_asc':
              return a.job.jobName.localeCompare(b.job.jobName);
            case 'job_desc':
              return b.job.jobName.localeCompare(a.job.jobName);
            case 'eff_desc':
              return b.efficiency - a.efficiency;
            case 'eff_asc':
              return a.efficiency - b.efficiency;
            case 'pieces_desc':
              return b.pieces - a.pieces;
            case 'pieces_asc':
              return a.pieces - b.pieces;
            case 'speed_desc':
              return b.speed - a.speed;
            case 'speed_asc':
              return a.speed - b.speed;
            case 'date_desc':
            default:
              return b.job.lastSeenTs - a.job.lastSeenTs;
          }
        });

        return withMetrics.map((x) => x.job);
      }

      function renderSummary(jobs) {
        const primaryUp = jobs.reduce((sum, job) => sum + getPrimaryTimes(job).uptimeSeconds, 0);
        const primaryDown = jobs.reduce((sum, job) => sum + getPrimaryTimes(job).downtimeSeconds, 0);
        const primaryEff = primaryUp + primaryDown === 0 ? 0 : (primaryUp / (primaryUp + primaryDown)) * 100;
        const totalPieces = jobs.reduce((s,j) => s + j.stats.totalPieces, 0);
        const totalReject = jobs.reduce((s,j) => s + j.stats.rejectPieces, 0);

        const cards = [
          ['Ingeladen bestanden', state.loadedFiles.length],
          ['Jobs', jobs.length],
          ['Totale uptime (JobStatistics primair)', formatDuration(primaryUp)],
          ['Totale downtime (JobStatistics primair)', formatDuration(primaryDown)],
          ['Gem. efficiëntie (JobStatistics primair)', `${primaryEff.toFixed(2)}%`],
          ['Total Pieces (JobStatistics)', totalPieces],
          ['Reject Pieces (JobStatistics)', totalReject]
        ];
        els.summaryCards.innerHTML = cards.map(([label, value]) => `<article class="card"><span>${label}</span><strong>${value}</strong></article>`).join('');
      }

      function getTopControllableDowntimeReason(timeline) {
        const entries = Array.from(timeline.reasons.entries())
          .filter(([reason]) => reason.toLowerCase() !== 'readynoproductfeed')
          .sort((a, b) => b[1] - a[1]);

        return entries[0]?.[0] || 'Geen overige downtime';
      }

      function renderJobTable(jobs, selectedJobName) {
        if (jobs.length === 0) {
          els.jobTableBody.innerHTML = '<tr><td colspan="10" class="muted">Geen jobs voor deze filter.</td></tr>';
          return;
        }
        els.jobTableBody.innerHTML = jobs.map((job) => {
          const t = job.timeline;
          const s = job.stats;
          const primary = getPrimaryTimes(job);
          const eff =
            primary.uptimeSeconds + primary.downtimeSeconds === 0
              ? 0
              : (primary.uptimeSeconds / (primary.uptimeSeconds + primary.downtimeSeconds)) * 100;
          const topReason = getTopControllableDowntimeReason(t);
          const prodRate = s.productionRateWeight === 0 ? 0 : s.productionRateWeightedSum / s.productionRateWeight;
          const goodPerUptimeHour = getGoodPerUptimeHour(job);
          const period = `${formatDateTime(job.firstSeenTs)} → ${formatDateTime(job.lastSeenTs)}`;
          const segments = getEfficiencyBarSegments(job);
          const rowClass = job.jobName === selectedJobName ? 'active-row' : '';
          return `<tr class="${rowClass}" data-job-name="${job.jobName}">
            <td>${job.jobName}</td>
            <td>${period}</td>
            <td>${formatDuration(primary.uptimeSeconds)}</td>
            <td>${formatDuration(primary.downtimeSeconds)}</td>
            <td>
              ${eff.toFixed(2)}%
              <div class="stacked-progress" aria-label="Uptime en downtime verdeling">
                <span class="seg up" style="width:${segments.upPct.toFixed(2)}%"></span>
                <span class="seg ready" style="width:${segments.readyPct.toFixed(2)}%"></span>
                <span class="seg other" style="width:${segments.otherPct.toFixed(2)}%"></span>
              </div>
            </td>
            <td>${s.totalPieces}</td>
            <td>${s.goodPieces} / ${s.rejectPieces}</td>
            <td>${prodRate.toFixed(2)}</td>
            <td>${goodPerUptimeHour.toFixed(2)}</td>
            <td>${topReason}</td>
          </tr>`;
        }).join('');
      }

      function renderJobSelector(jobs, selectedJobName) {
        if (jobs.length === 0) { els.jobSelect.innerHTML = ''; return; }
        els.jobSelect.innerHTML = jobs
          .map((j) => `<option value="${j.jobName}">${j.jobName} (${formatDateTime(j.firstSeenTs)})</option>`)
          .join('');
        if (jobs.some((j) => j.jobName === selectedJobName)) {
          els.jobSelect.value = selectedJobName;
        }
      }

      function getDowntimeBreakdownForDetail(job) {
        const primary = getPrimaryTimes(job);
        const reasons = Array.from(job.timeline.reasons.entries());
        const ready = reasons
          .filter(([reason]) => reason.toLowerCase() === 'readynoproductfeed')
          .reduce((sum, [, sec]) => sum + sec, 0);
        const otherKnown = reasons
          .filter(([reason]) => reason.toLowerCase() !== 'readynoproductfeed')
          .reduce((sum, [, sec]) => sum + sec, 0);
        const missing = Math.max(0, primary.downtimeSeconds - (ready + otherKnown));
        return {
          uptime: primary.uptimeSeconds,
          readyDowntime: ready,
          otherDowntime: otherKnown + missing
        };
      }

      function drawJobPieChart(breakdown) {
        const canvas = els.jobPieChart;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const items = [
          { key: 'Uptime', value: breakdown.uptime, color: '#22a06b' },
          { key: 'Downtime ReadyNoProductFeed', value: breakdown.readyDowntime, color: '#f6c547' },
          { key: 'Overige downtime', value: breakdown.otherDowntime, color: '#e34b4b' }
        ];
        const total = items.reduce((s, i) => s + i.value, 0);
        if (total <= 0) return items;

        let start = -Math.PI / 2;
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = 82;

        for (const item of items) {
          const angle = (item.value / total) * Math.PI * 2;
          if (angle <= 0) continue;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.arc(cx, cy, radius, start, start + angle);
          ctx.closePath();
          ctx.fillStyle = item.color;
          ctx.fill();
          start += angle;
        }

        ctx.beginPath();
        ctx.arc(cx, cy, 38, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        return items;
      }

      function renderJobSideDetail(job) {
        if (!job) {
          els.jobDetailTitle.textContent = 'Klik op een job in de tabel.';
          els.jobPieLegend.innerHTML = '';
          els.jobDowntimeList.innerHTML = '<li class="muted">Geen job geselecteerd.</li>';
          const ctx = els.jobPieChart.getContext('2d');
          ctx.clearRect(0, 0, els.jobPieChart.width, els.jobPieChart.height);
          return;
        }

        const breakdown = getDowntimeBreakdownForDetail(job);
        const parts = drawJobPieChart(breakdown);
        const total = breakdown.uptime + breakdown.readyDowntime + breakdown.otherDowntime;

        els.jobDetailTitle.innerHTML = `<strong>${job.jobName}</strong><br><span class="muted">Totale jobduur: ${formatDuration(total)}</span>`;

        els.jobPieLegend.innerHTML = parts.map((part) => {
          const pct = total === 0 ? 0 : (part.value / total) * 100;
          return `<div class="legend-item"><span><span class="dot" style="background:${part.color}"></span>${part.key}</span><strong>${formatDuration(part.value)} (${pct.toFixed(1)}%)</strong></div>`;
        }).join('');

        const reasonEntries = Array.from(job.timeline.reasons.entries()).sort((a, b) => b[1] - a[1]);
        const listedReasons = [...reasonEntries];
        const missing = Math.max(0, breakdown.otherDowntime - reasonEntries
          .filter(([reason]) => reason.toLowerCase() !== 'readynoproductfeed')
          .reduce((sum, [, sec]) => sum + sec, 0));

        if (missing > 0) {
          listedReasons.push(['Onbekende downtime (ontbreekt in timeline)', missing]);
        }

        if (listedReasons.length === 0) {
          els.jobDowntimeList.innerHTML = '<li class="muted">Geen downtime regels in timeline voor deze job.</li>';
          return;
        }

        els.jobDowntimeList.innerHTML = listedReasons
          .sort((a, b) => b[1] - a[1])
          .map(([reason, sec]) => `<li>${reason}: <strong>${formatDuration(sec)}</strong></li>`)
          .join('');
      }

      function renderDowntimeReasonsTab(jobs) {
        const reasonTotals = new Map();

        for (const job of jobs) {
          for (const [reason, seconds] of job.timeline.reasons.entries()) {
            reasonTotals.set(reason, (reasonTotals.get(reason) || 0) + seconds);
          }
        }

        const rows = Array.from(reasonTotals.entries()).sort((a, b) => b[1] - a[1]);
        const totalDowntime = rows.reduce((sum, [, seconds]) => sum + seconds, 0);

        if (!rows.some(([reason]) => reason === state.selectedDowntimeReason)) {
          state.selectedDowntimeReason = rows[0]?.[0] || '';
        }

        if (rows.length === 0) {
          els.downtimeReasonTableBody.innerHTML = '<tr><td colspan="3" class="muted">Nog geen downtime data beschikbaar.</td></tr>';
          return;
        }

        els.downtimeReasonTableBody.innerHTML = rows
          .map(([reason, seconds]) => {
            const pct = totalDowntime === 0 ? 0 : (seconds / totalDowntime) * 100;
            const rowClass = reason === state.selectedDowntimeReason ? 'active-row' : '';
            return `<tr class="${rowClass}" data-reason="${reason}"><td>${reason}</td><td>${formatDuration(seconds)}</td><td>${pct.toFixed(1)}%</td></tr>`;
          })
          .join('');
      }

      function renderDowntimeReasonDetail(jobs) {
        const reason = state.selectedDowntimeReason;
        if (!reason) {
          els.downtimeReasonTitle.textContent = 'Klik op een downtime reden in de tabel.';
          els.downtimeReasonEvents.innerHTML = '<li class="muted">Geen downtime reden geselecteerd.</li>';
          return;
        }

        const occurrences = [];
        for (const event of state.timelineEvents) {
          if (!event.jobName) continue;
          if (event.reason !== reason) continue;
          occurrences.push(event);
        }

        occurrences.sort((a, b) => (b.startTimestamp || 0) - (a.startTimestamp || 0));
        const totalSeconds = occurrences.reduce((sum, e) => sum + e.durationSeconds, 0);

        els.downtimeReasonTitle.innerHTML = `<strong>${reason}</strong><br><span class="muted">Totale downtime: ${formatDuration(totalSeconds)} · ${occurrences.length} keer</span>`;

        if (occurrences.length === 0) {
          els.downtimeReasonEvents.innerHTML = '<li class="muted">Geen voorvallen gevonden in timeline.</li>';
          return;
        }

        els.downtimeReasonEvents.innerHTML = occurrences
          .map((e) => `<li><strong>${e.jobName}</strong> · ${formatDateTime(e.startTimestamp)} · duur: <strong>${formatDuration(e.durationSeconds)}</strong></li>`)
          .join('');
      }

      function renderTabs() {
        const active = state.activeTab;
        const showImport = active === 'import';
        const showOverview = active === 'overview';
        const showDowntime = active === 'downtime';

        els.tabImportBtn.classList.toggle('active', showImport);
        els.tabOverviewBtn.classList.toggle('active', showOverview);
        els.tabDowntimeBtn.classList.toggle('active', showDowntime);

        els.tabImportBtn.setAttribute('aria-selected', showImport ? 'true' : 'false');
        els.tabOverviewBtn.setAttribute('aria-selected', showOverview ? 'true' : 'false');
        els.tabDowntimeBtn.setAttribute('aria-selected', showDowntime ? 'true' : 'false');

        els.importTab.classList.toggle('hidden', !showImport);
        els.overviewTab.classList.toggle('hidden', !showOverview);
        els.downtimeTab.classList.toggle('hidden', !showDowntime);
      }

      function renderCrossSection(jobName) {
        const job = aggregateByJob().find((j) => j.jobName === jobName);
        if (!job) {
          els.selectedJobStats.innerHTML = '<p class="muted">Geen job geselecteerd.</p>';
          els.reasonBreakdown.innerHTML = '';
          return;
        }

        const t = job.timeline;
        const s = job.stats;
        const primary = getPrimaryTimes(job);
        const primaryEff =
          primary.uptimeSeconds + primary.downtimeSeconds === 0
            ? 0
            : (primary.uptimeSeconds / (primary.uptimeSeconds + primary.downtimeSeconds)) * 100;
        const timelineEff = t.uptimeSeconds + t.downtimeSeconds === 0 ? 0 : (t.uptimeSeconds / (t.uptimeSeconds + t.downtimeSeconds)) * 100;
        const jobStatsEff = s.totalTimeSeconds === 0 ? 0 : (s.uptimeSeconds / s.totalTimeSeconds) * 100;
        const prodRate = s.productionRateWeight === 0 ? 0 : s.productionRateWeightedSum / s.productionRateWeight;

        els.selectedJobStats.innerHTML = `
          <div class="cards">
            <article class="card"><span>Job</span><strong>${job.jobName}</strong></article>
            <article class="card"><span>Periode</span><strong>${formatDateTime(job.firstSeenTs)} → ${formatDateTime(job.lastSeenTs)}</strong></article>
            <article class="card"><span>Efficiëntie (JobStatistics primair)</span><strong>${primaryEff.toFixed(2)}%</strong></article>
            <article class="card"><span>Efficiëntie (timeline detail)</span><strong>${timelineEff.toFixed(2)}%</strong></article>
            <article class="card"><span>JobStatistics uptime-rate</span><strong>${jobStatsEff.toFixed(2)}%</strong></article>
            <article class="card"><span>Uptime/Downtime (primair)</span><strong>${formatDuration(primary.uptimeSeconds)} / ${formatDuration(primary.downtimeSeconds)}</strong></article>
            <article class="card"><span>Total Pieces</span><strong>${s.totalPieces}</strong></article>
            <article class="card"><span>Good/Reject</span><strong>${s.goodPieces} / ${s.rejectPieces}</strong></article>
            <article class="card"><span>Production Rate</span><strong>${prodRate.toFixed(2)}</strong></article>
            <article class="card"><span>Snelheid tijdens uptime (good/uur)</span><strong>${getGoodPerUptimeHour(job).toFixed(2)}</strong></article>
            <article class="card"><span>Shift</span><strong>${s.lastShiftName || '-'}</strong></article>
            <article class="card"><span>Uptime/Unscheduled DT (JobStatistics)</span><strong>${formatDuration(s.uptimeSeconds)} / ${formatDuration(s.unscheduledDowntimeSeconds)}</strong></article>
          </div>
        `;

        const reasons = Array.from(t.reasons.entries()).sort((a,b)=>b[1]-a[1]);
        if (reasons.length === 0) {
          state.selectedCrossReason = '';
          els.reasonBreakdown.innerHTML = '<p class="muted">Geen downtime oorzaken in timeline voor deze job.</p>';
          els.crossReasonTitle.textContent = 'Geen downtime oorzaken beschikbaar voor deze job.';
          els.crossReasonEvents.innerHTML = '<li class="muted">Geen events om te tonen.</li>';
          return;
        }

        if (!reasons.some(([reason]) => reason === state.selectedCrossReason)) {
          state.selectedCrossReason = reasons[0][0];
        }

        els.reasonBreakdown.innerHTML = reasons.map(([reason, sec]) => {
          const pct = t.downtimeSeconds === 0 ? 0 : (sec / t.downtimeSeconds) * 100;
          const activeClass = reason === state.selectedCrossReason ? 'active-reason' : '';
          return `<div class="reason-row clickable ${activeClass}" data-cross-reason="${reason}"><div><div>${reason} (${formatDuration(sec)})</div><div class="progress"><span style="width:${pct.toFixed(2)}%"></span></div></div><strong>${pct.toFixed(1)}%</strong></div>`;
        }).join('');

        const selectedReason = state.selectedCrossReason;
        const events = state.timelineEvents
          .filter((event) => event.jobName === job.jobName && event.reason === selectedReason)
          .sort((a, b) => (b.startTimestamp || 0) - (a.startTimestamp || 0));
        const total = events.reduce((sum, event) => sum + event.durationSeconds, 0);

        els.crossReasonTitle.innerHTML = `<strong>${selectedReason}</strong><br><span class="muted">${events.length} keer · totale duur ${formatDuration(total)}</span>`;

        if (events.length === 0) {
          els.crossReasonEvents.innerHTML = '<li class="muted">Geen events gevonden voor deze downtime-reden.</li>';
          return;
        }

        els.crossReasonEvents.innerHTML = events
          .map((event) => `<li>${formatDateTime(event.startTimestamp)} · duur: <strong>${formatDuration(event.durationSeconds)}</strong></li>`)
          .join('');
      }

      render();
    </script>
  </body>
</html>
