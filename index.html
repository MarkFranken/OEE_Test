<!doctype html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Machine Timeline Dashboard</title>
    <style>
      :root {
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: #18212f;
        background: #eef2f7;
      }
      body { margin: 0; }
      .container { max-width: 1200px; margin: 0 auto; padding: 2rem 1rem 3rem; }
      h1,h2,h3 { margin-top: 0; }
      .panel { background: #fff; border-radius: 14px; padding: 1rem; margin-top: 1rem; box-shadow: 0 2px 10px rgba(20,35,59,0.08); }
      .uploader { display: grid; gap: .75rem; }
      .button { border: none; background: #1768ff; color: #fff; border-radius: 8px; padding: .65rem .9rem; font-weight: 600; cursor: pointer; width: fit-content; }
      .button.secondary { background: #425466; }
      #fileInput { display: none; }
      .status,.muted { color: #4f6478; margin: 0; }
      .loaded-files { margin: 0; padding-left: 1rem; }
      .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: .75rem; }
      .card { background: #f5f8fe; border: 1px solid #dbe4f1; border-radius: 10px; padding: .8rem; }
      .card strong { display: block; margin-top: .3rem; font-size: 1.1rem; }
      .table-wrapper { overflow-x: auto; }
      table { width: 100%; border-collapse: collapse; }
      th,td { text-align: left; border-bottom: 1px solid #e5eaf2; padding: .55rem; vertical-align: top; }
      .progress { width: 100%; height: 12px; background: #eff3f9; border-radius: 999px; overflow: hidden; }
      .progress > span { display: block; height: 100%; background: linear-gradient(90deg,#2a7bff,#23c29f); }
      .reason-row { display:grid; grid-template-columns: 1fr 80px; align-items: center; gap:.75rem; margin-bottom:.5rem; }
      #jobSelect { margin: .5rem 0 1rem; padding: .5rem; }
      .meta { display:flex; flex-wrap:wrap; gap:.5rem; }
      .pill { padding:.2rem .55rem; border-radius:999px; background:#eaf1ff; color:#275299; font-size:.8rem; font-weight:600; }
      .tip { margin:0; font-size:.92rem; color:#4a5f74; }
      .table-controls { display:flex; flex-wrap:wrap; gap:.6rem; margin:.4rem 0 .8rem; align-items:end; }
      .field { display:grid; gap:.2rem; }
      .field label { font-size:.82rem; color:#4f6478; }
      .field input,.field select { padding:.45rem .5rem; border:1px solid #cfd9e6; border-radius:8px; min-width:180px; }
      .jobs-layout { display:grid; grid-template-columns: minmax(0, 1fr) 360px; gap:1rem; }
      .job-detail { border:1px solid #dbe4f1; border-radius:12px; padding:.9rem; background:#f9fbff; position:sticky; top:1rem; align-self:start; max-height:calc(100vh - 2rem); overflow:auto; }
      @media (max-width: 1100px) { .jobs-layout { grid-template-columns: 1fr; } .job-detail { position:static; max-height:none; } }
      .job-detail h3 { margin-bottom:.5rem; }
      .job-detail canvas { width:100%; max-width:220px; display:block; margin:.3rem auto .8rem; }
      .legend { display:grid; gap:.35rem; margin-bottom:.8rem; }
      .legend-item { display:flex; align-items:center; justify-content:space-between; gap:.6rem; font-size:.9rem; }
      .dot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:.35rem; }
      .jobs-table tbody tr { cursor:pointer; }
      .jobs-table tbody tr.active-row { background:#eef5ff; }
      .downtime-list { margin:0; padding-left:1rem; display:grid; gap:.25rem; }
    </style>
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Machine Timeline Dashboard</h1>
        <p>Laad zowel <code>Timeline CSV</code> als <code>JobStatistics CSV</code> in. Dubbele bestanden worden automatisch geweigerd.</p>
      </header>

      <section class="panel uploader">
        <label for="fileInput" class="button">Kies CSV-bestand(en)</label>
        <input id="fileInput" type="file" accept=".csv,text/csv" multiple />
        <button id="clearBtn" class="button secondary" type="button">Leeg dataset</button>
        <p class="tip">Je kunt deze pagina direct openen via dubbelklik op <code>index.html</code>.</p>
        <p id="status" class="status">Nog geen bestanden geladen.</p>
        <div id="fileTypeInfo" class="meta"></div>
        <ul id="loadedFiles" class="loaded-files"></ul>
      </section>

      <section class="panel">
        <h2>Overzicht</h2>
        <div id="summaryCards" class="cards"></div>
      </section>

      <section class="panel">
        <h2>Efficiëntie per job</h2>
        <div class="table-controls">
          <div class="field">
            <label for="jobFilterInput">Filter op jobnaam of downtime reden</label>
            <input id="jobFilterInput" type="text" placeholder="bijv. 42834 of ReadyNoProductFeed" />
          </div>
          <div class="field">
            <label for="sortBySelect">Sorteer op</label>
            <select id="sortBySelect">
              <option value="date_desc">Datum (nieuwste eerst)</option>
              <option value="date_asc">Datum (oudste eerst)</option>
              <option value="job_asc">Jobnaam (A-Z)</option>
              <option value="job_desc">Jobnaam (Z-A)</option>
              <option value="eff_desc">Efficiëntie hoog-laag</option>
              <option value="eff_asc">Efficiëntie laag-hoog</option>
              <option value="pieces_desc">Total Pieces hoog-laag</option>
              <option value="pieces_asc">Total Pieces laag-hoog</option>
              <option value="speed_desc">Snelheid uptime hoog-laag</option>
              <option value="speed_asc">Snelheid uptime laag-hoog</option>
            </select>
          </div>
        </div>
        <div class="jobs-layout">
          <div class="table-wrapper">
            <table class="jobs-table">
              <thead>
                <tr>
                  <th>Job</th>
                  <th>Periode</th>
                  <th>Uptime (JobStatistics primair)</th>
                  <th>Downtime (JobStatistics primair)</th>
                  <th>Efficiëntie (JobStatistics primair)</th>
                  <th>Total Pieces</th>
                  <th>Good/Reject</th>
                  <th>Production Rate</th>
                  <th>Snelheid tijdens uptime (good/uur)</th>
                  <th>Belangrijkste downtime oorzaak</th>
                </tr>
              </thead>
              <tbody id="jobTableBody"></tbody>
            </table>
          </div>
          <aside class="job-detail" id="jobDetailPanel">
            <h3>Job detail</h3>
            <p id="jobDetailTitle" class="muted">Klik op een job in de tabel.</p>
            <canvas id="jobPieChart" width="220" height="220" aria-label="Job verdeling chart"></canvas>
            <div id="jobPieLegend" class="legend"></div>
            <h4>Downtimes in deze job</h4>
            <ul id="jobDowntimeList" class="downtime-list"></ul>
          </aside>
        </div>
      </section>

      <section class="panel">
        <h2>Dwarsdoorsnede per job</h2>
        <label for="jobSelect">Selecteer job:</label>
        <select id="jobSelect"></select>
        <div id="selectedJobStats"></div>
        <h3>Downtime oorzaken (timeline)</h3>
        <div id="reasonBreakdown"></div>
      </section>
    </main>

    <script>
      const els = {
        fileInput: document.getElementById('fileInput'),
        clearBtn: document.getElementById('clearBtn'),
        status: document.getElementById('status'),
        fileTypeInfo: document.getElementById('fileTypeInfo'),
        loadedFiles: document.getElementById('loadedFiles'),
        summaryCards: document.getElementById('summaryCards'),
        jobTableBody: document.getElementById('jobTableBody'),
        jobSelect: document.getElementById('jobSelect'),
        selectedJobStats: document.getElementById('selectedJobStats'),
        reasonBreakdown: document.getElementById('reasonBreakdown'),
        jobFilterInput: document.getElementById('jobFilterInput'),
        sortBySelect: document.getElementById('sortBySelect'),
        jobDetailTitle: document.getElementById('jobDetailTitle'),
        jobPieChart: document.getElementById('jobPieChart'),
        jobPieLegend: document.getElementById('jobPieLegend'),
        jobDowntimeList: document.getElementById('jobDowntimeList')
      };

      const state = {
        signatures: new Set(),
        loadedFiles: [],
        timelineEvents: [],
        jobStatisticsRows: [],
        tableFilterText: '',
        tableSortBy: 'date_desc',
        selectedJobName: ''
      };

      const HEADERS = {
        timeline: 'start time,shift id,production state,reason,duration,job name',
        jobStats: 'job start time,job end time,job name,current user,additional data,total pieces,good pieces,reject pieces,bad piece rate,total time,scheduled downtime,unscheduled downtime,uptime,good production time,nominal production time,nominal production time rate,scheduled downtime rate,unscheduled downtime rate,production rate,shift name'
      };

      els.fileInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files || []);
        if (files.length === 0) return;

        let added = 0;
        let duplicates = 0;
        let unsupported = 0;

        for (const file of files) {
          const content = await file.text();
          const signature = await getSignature(content);
          if (state.signatures.has(signature)) { duplicates += 1; continue; }

          const parsed = parseCsvByType(content);
          if (parsed.type === 'unknown') { unsupported += 1; continue; }

          state.signatures.add(signature);
          state.loadedFiles.push({ name: file.name, type: parsed.type });
          if (parsed.type === 'timeline') state.timelineEvents.push(...parsed.rows);
          if (parsed.type === 'jobStats') state.jobStatisticsRows.push(...parsed.rows);
          added += 1;
        }

        event.target.value = '';
        render({ added, duplicates, unsupported });
      });

      els.clearBtn.addEventListener('click', () => {
        state.signatures.clear();
        state.loadedFiles = [];
        state.timelineEvents = [];
        state.jobStatisticsRows = [];
        render({ added: 0, duplicates: 0, unsupported: 0 });
      });

      els.jobSelect.addEventListener('change', () => {
        state.selectedJobName = els.jobSelect.value;
        render();
      });

      els.jobTableBody.addEventListener('click', (event) => {
        const row = event.target.closest('tr[data-job-name]');
        if (!row) return;
        state.selectedJobName = row.dataset.jobName;
        render();
      });

      els.jobFilterInput.addEventListener('input', (event) => {
        state.tableFilterText = (event.target.value || '').trim().toLowerCase();
        render();
      });

      els.sortBySelect.addEventListener('change', (event) => {
        state.tableSortBy = event.target.value;
        render();
      });

      function splitCsvLine(line) { return line.split(','); }

      function parseCsvByType(raw) {
        const lines = raw.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
        const normalized = lines.map((l) => l.toLowerCase());

        const timelineIdx = normalized.findIndex((l) => l.startsWith(HEADERS.timeline));
        if (timelineIdx !== -1) {
          const rows = lines.slice(timelineIdx + 1).map((line) => {
            const [startTime, shiftId, productionState, reason, duration, jobName] = splitCsvLine(line);
            return {
              startTime,
              startTimestamp: parseDateTime(startTime),
              shiftId,
              productionState,
              reason: reason || 'Onbekend',
              durationSeconds: durationToSeconds(duration),
              jobName,
              endTimestamp: parseDateTime(startTime) + durationToSeconds(duration) * 1000
            };
          }).filter((r) => r.jobName && r.startTime !== '1970-01-01 00:00:00');
          return { type: 'timeline', rows };
        }

        const jobIdx = normalized.findIndex((l) => l.startsWith(HEADERS.jobStats));
        if (jobIdx !== -1) {
          const rows = lines.slice(jobIdx + 1).map((line) => {
            const [jobStartTime, jobEndTime, jobName, currentUser, additionalData, totalPieces, goodPieces, rejectPieces, badPieceRate, totalTime, scheduledDowntime, unscheduledDowntime, uptime, goodProductionTime, nominalProductionTime, nominalProductionTimeRate, scheduledDowntimeRate, unscheduledDowntimeRate, productionRate, shiftName] = splitCsvLine(line);
            return {
              jobStartTime, jobEndTime, jobName,
              jobStartTimestamp: parseDateTime(jobStartTime),
              jobEndTimestamp: parseDateTime(jobEndTime),
              currentUser, additionalData,
              totalPieces: Number(totalPieces || 0),
              goodPieces: Number(goodPieces || 0),
              rejectPieces: Number(rejectPieces || 0),
              badPieceRate: Number(badPieceRate || 0),
              totalTimeSeconds: durationToSeconds(totalTime),
              scheduledDowntimeSeconds: durationToSeconds(scheduledDowntime),
              unscheduledDowntimeSeconds: durationToSeconds(unscheduledDowntime),
              uptimeSeconds: durationToSeconds(uptime),
              goodProductionTimeSeconds: durationToSeconds(goodProductionTime),
              nominalProductionTimeSeconds: durationToSeconds(nominalProductionTime),
              nominalProductionTimeRate: Number(nominalProductionTimeRate || 0),
              scheduledDowntimeRate: Number(scheduledDowntimeRate || 0),
              unscheduledDowntimeRate: Number(unscheduledDowntimeRate || 0),
              productionRate: Number(productionRate || 0),
              shiftName
            };
          }).filter((r) => r.jobName);
          return { type: 'jobStats', rows };
        }

        return { type: 'unknown', rows: [] };
      }

      async function getSignature(text) {
        const data = new TextEncoder().encode(text);
        if (window.crypto && window.crypto.subtle) {
          const digest = await window.crypto.subtle.digest('SHA-256', data);
          return Array.from(new Uint8Array(digest)).map((b) => b.toString(16).padStart(2, '0')).join('');
        }
        let hash = 0;
        for (const byte of data) hash = (hash * 31 + byte) >>> 0;
        return String(hash);
      }

      function durationToSeconds(value) {
        const parts = (value || '').split(':').map(Number);
        if (parts.length !== 3 || parts.some(Number.isNaN)) return 0;
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      }

      function formatDuration(seconds) {
        const s = Math.max(0, Math.floor(seconds || 0));
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
      }

      function parseDateTime(value) {
        if (!value) return NaN;
        const ts = new Date(value.replace(' ', 'T')).getTime();
        return Number.isFinite(ts) ? ts : NaN;
      }

      function formatDateTime(value) {
        if (!Number.isFinite(value)) return '-';
        const d = new Date(value);
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${y}-${m}-${day} ${hh}:${mm}`;
      }

      function aggregateByJob() {
        const byJob = new Map();
        const ensure = (jobName) => {
          if (!byJob.has(jobName)) {
            byJob.set(jobName, {
              jobName,
              timeline: { uptimeSeconds: 0, downtimeSeconds: 0, reasons: new Map() },
              stats: {
                totalPieces: 0, goodPieces: 0, rejectPieces: 0,
                totalTimeSeconds: 0, uptimeSeconds: 0, scheduledDowntimeSeconds: 0, unscheduledDowntimeSeconds: 0,
                productionRateWeightedSum: 0, productionRateWeight: 0, lastShiftName: ''
              },
              firstSeenTs: Infinity,
              lastSeenTs: -Infinity
            });
          }
          return byJob.get(jobName);
        };

        for (const event of state.timelineEvents) {
          const job = ensure(event.jobName);
          const isUptime = (event.productionState || '').toLowerCase() === 'uptime';
          if (isUptime) {
            job.timeline.uptimeSeconds += event.durationSeconds;
          } else {
            job.timeline.downtimeSeconds += event.durationSeconds;
            job.timeline.reasons.set(event.reason, (job.timeline.reasons.get(event.reason) || 0) + event.durationSeconds);
          }
          if (Number.isFinite(event.startTimestamp)) {
            job.firstSeenTs = Math.min(job.firstSeenTs, event.startTimestamp);
          }
          if (Number.isFinite(event.endTimestamp)) {
            job.lastSeenTs = Math.max(job.lastSeenTs, event.endTimestamp);
          }
        }

        for (const row of state.jobStatisticsRows) {
          const job = ensure(row.jobName);
          job.stats.totalPieces += row.totalPieces;
          job.stats.goodPieces += row.goodPieces;
          job.stats.rejectPieces += row.rejectPieces;
          job.stats.totalTimeSeconds += row.totalTimeSeconds;
          job.stats.uptimeSeconds += row.uptimeSeconds;
          job.stats.scheduledDowntimeSeconds += row.scheduledDowntimeSeconds;
          job.stats.unscheduledDowntimeSeconds += row.unscheduledDowntimeSeconds;
          job.stats.productionRateWeightedSum += row.productionRate * Math.max(1, row.totalTimeSeconds);
          job.stats.productionRateWeight += Math.max(1, row.totalTimeSeconds);
          job.stats.lastShiftName = row.shiftName || job.stats.lastShiftName;
          if (Number.isFinite(row.jobStartTimestamp)) {
            job.firstSeenTs = Math.min(job.firstSeenTs, row.jobStartTimestamp);
          }
          if (Number.isFinite(row.jobEndTimestamp)) {
            job.lastSeenTs = Math.max(job.lastSeenTs, row.jobEndTimestamp);
          }
        }

        return Array.from(byJob.values())
          .filter((job) => job.jobName && job.jobName.toLowerCase() !== 'base')
          .sort((a,b) => {
            if (a.lastSeenTs !== b.lastSeenTs) return b.lastSeenTs - a.lastSeenTs;
            return a.jobName.localeCompare(b.jobName);
          });
      }

      function render(meta = { added: 0, duplicates: 0, unsupported: 0 }) {
        const jobs = aggregateByJob();
        const filteredSortedJobs = getFilteredSortedJobs(jobs);

        els.loadedFiles.innerHTML = state.loadedFiles.map((f) => `<li>${f.name} <span class="pill">${f.type === 'timeline' ? 'timeline' : 'jobstats'}</span></li>`).join('');
        const timelineCount = state.loadedFiles.filter((f) => f.type === 'timeline').length;
        const statsCount = state.loadedFiles.filter((f) => f.type === 'jobStats').length;
        els.fileTypeInfo.innerHTML = `<span class="pill">Timeline bestanden: ${timelineCount}</span><span class="pill">JobStatistics bestanden: ${statsCount}</span><span class="pill">Tabel jobs: ${filteredSortedJobs.length}</span>`;

        if (state.loadedFiles.length === 0) {
          els.status.textContent = 'Nog geen bestanden geladen.';
        } else {
          els.status.textContent = `${meta.added} bestand(en) toegevoegd, ${meta.duplicates} dubbel(e) overgeslagen, ${meta.unsupported} niet-herkend.`;
        }

        renderSummary(jobs);
        const selectedFromFiltered = filteredSortedJobs.find((j) => j.jobName === state.selectedJobName)?.jobName;
        const selectedJobName = selectedFromFiltered || filteredSortedJobs[0]?.jobName || jobs[0]?.jobName || '';
        state.selectedJobName = selectedJobName;
        renderJobTable(filteredSortedJobs, selectedJobName);
        renderJobSelector(filteredSortedJobs, selectedJobName);
        renderJobSideDetail(jobs.find((j) => j.jobName === selectedJobName));
        renderCrossSection(selectedJobName);
      }

      function getPrimaryTimes(job) {
        const stats = job.stats;
        const timeline = job.timeline;

        const hasJobStats =
          stats.totalTimeSeconds > 0 ||
          stats.uptimeSeconds > 0 ||
          stats.scheduledDowntimeSeconds > 0 ||
          stats.unscheduledDowntimeSeconds > 0;

        if (hasJobStats) {
          const uptime = Math.max(0, stats.uptimeSeconds);
          const downtimeByParts = Math.max(0, stats.scheduledDowntimeSeconds + stats.unscheduledDowntimeSeconds);
          const downtimeByTotal = Math.max(0, stats.totalTimeSeconds - uptime);
          const downtime = Math.max(downtimeByParts, downtimeByTotal);
          return {
            source: 'jobstats',
            uptimeSeconds: uptime,
            downtimeSeconds: downtime
          };
        }

        return {
          source: 'timeline',
          uptimeSeconds: Math.max(0, timeline.uptimeSeconds),
          downtimeSeconds: Math.max(0, timeline.downtimeSeconds)
        };
      }

      function getGoodPerUptimeHour(job) {
        const primary = getPrimaryTimes(job);
        const uptimeHours = primary.uptimeSeconds / 3600;
        if (uptimeHours <= 0) return 0;
        return job.stats.goodPieces / uptimeHours;
      }

      function getFilteredSortedJobs(jobs) {
        const filterText = state.tableFilterText;

        const filtered = jobs.filter((job) => {
          if (!filterText) return true;
          const topReason = Array.from(job.timeline.reasons.keys()).join(' ').toLowerCase();
          return job.jobName.toLowerCase().includes(filterText) || topReason.includes(filterText);
        });

        const withMetrics = filtered.map((job) => {
          const primary = getPrimaryTimes(job);
          const efficiency =
            primary.uptimeSeconds + primary.downtimeSeconds === 0
              ? 0
              : (primary.uptimeSeconds / (primary.uptimeSeconds + primary.downtimeSeconds)) * 100;
          return { job, efficiency, pieces: job.stats.totalPieces || 0, speed: getGoodPerUptimeHour(job) };
        });

        withMetrics.sort((a, b) => {
          switch (state.tableSortBy) {
            case 'date_asc':
              return a.job.firstSeenTs - b.job.firstSeenTs;
            case 'job_asc':
              return a.job.jobName.localeCompare(b.job.jobName);
            case 'job_desc':
              return b.job.jobName.localeCompare(a.job.jobName);
            case 'eff_desc':
              return b.efficiency - a.efficiency;
            case 'eff_asc':
              return a.efficiency - b.efficiency;
            case 'pieces_desc':
              return b.pieces - a.pieces;
            case 'pieces_asc':
              return a.pieces - b.pieces;
            case 'speed_desc':
              return b.speed - a.speed;
            case 'speed_asc':
              return a.speed - b.speed;
            case 'date_desc':
            default:
              return b.job.lastSeenTs - a.job.lastSeenTs;
          }
        });

        return withMetrics.map((x) => x.job);
      }

      function renderSummary(jobs) {
        const primaryUp = jobs.reduce((sum, job) => sum + getPrimaryTimes(job).uptimeSeconds, 0);
        const primaryDown = jobs.reduce((sum, job) => sum + getPrimaryTimes(job).downtimeSeconds, 0);
        const primaryEff = primaryUp + primaryDown === 0 ? 0 : (primaryUp / (primaryUp + primaryDown)) * 100;
        const totalPieces = jobs.reduce((s,j) => s + j.stats.totalPieces, 0);
        const totalReject = jobs.reduce((s,j) => s + j.stats.rejectPieces, 0);

        const cards = [
          ['Ingeladen bestanden', state.loadedFiles.length],
          ['Jobs', jobs.length],
          ['Totale uptime (JobStatistics primair)', formatDuration(primaryUp)],
          ['Totale downtime (JobStatistics primair)', formatDuration(primaryDown)],
          ['Gem. efficiëntie (JobStatistics primair)', `${primaryEff.toFixed(2)}%`],
          ['Total Pieces (JobStatistics)', totalPieces],
          ['Reject Pieces (JobStatistics)', totalReject]
        ];
        els.summaryCards.innerHTML = cards.map(([label, value]) => `<article class="card"><span>${label}</span><strong>${value}</strong></article>`).join('');
      }

      function renderJobTable(jobs, selectedJobName) {
        if (jobs.length === 0) {
          els.jobTableBody.innerHTML = '<tr><td colspan="10" class="muted">Geen jobs voor deze filter.</td></tr>';
          return;
        }
        els.jobTableBody.innerHTML = jobs.map((job) => {
          const t = job.timeline;
          const s = job.stats;
          const primary = getPrimaryTimes(job);
          const eff =
            primary.uptimeSeconds + primary.downtimeSeconds === 0
              ? 0
              : (primary.uptimeSeconds / (primary.uptimeSeconds + primary.downtimeSeconds)) * 100;
          const topReason = Array.from(t.reasons.entries()).sort((a,b)=>b[1]-a[1])[0]?.[0] || 'Geen';
          const prodRate = s.productionRateWeight === 0 ? 0 : s.productionRateWeightedSum / s.productionRateWeight;
          const goodPerUptimeHour = getGoodPerUptimeHour(job);
          const period = `${formatDateTime(job.firstSeenTs)} → ${formatDateTime(job.lastSeenTs)}`;
          const rowClass = job.jobName === selectedJobName ? 'active-row' : '';
          return `<tr class="${rowClass}" data-job-name="${job.jobName}">
            <td>${job.jobName}</td>
            <td>${period}</td>
            <td>${formatDuration(primary.uptimeSeconds)}</td>
            <td>${formatDuration(primary.downtimeSeconds)}</td>
            <td>${eff.toFixed(2)}%<div class="progress"><span style="width:${eff.toFixed(2)}%"></span></div></td>
            <td>${s.totalPieces}</td>
            <td>${s.goodPieces} / ${s.rejectPieces}</td>
            <td>${prodRate.toFixed(2)}</td>
            <td>${goodPerUptimeHour.toFixed(2)}</td>
            <td>${topReason}</td>
          </tr>`;
        }).join('');
      }

      function renderJobSelector(jobs, selectedJobName) {
        if (jobs.length === 0) { els.jobSelect.innerHTML = ''; return; }
        els.jobSelect.innerHTML = jobs
          .map((j) => `<option value="${j.jobName}">${j.jobName} (${formatDateTime(j.firstSeenTs)})</option>`)
          .join('');
        if (jobs.some((j) => j.jobName === selectedJobName)) {
          els.jobSelect.value = selectedJobName;
        }
      }

      function getDowntimeBreakdownForDetail(job) {
        const primary = getPrimaryTimes(job);
        const reasons = Array.from(job.timeline.reasons.entries());
        const ready = reasons
          .filter(([reason]) => reason.toLowerCase() === 'readynoproductfeed')
          .reduce((sum, [, sec]) => sum + sec, 0);
        const otherKnown = reasons
          .filter(([reason]) => reason.toLowerCase() !== 'readynoproductfeed')
          .reduce((sum, [, sec]) => sum + sec, 0);
        const missing = Math.max(0, primary.downtimeSeconds - (ready + otherKnown));
        return {
          uptime: primary.uptimeSeconds,
          readyDowntime: ready,
          otherDowntime: otherKnown + missing
        };
      }

      function drawJobPieChart(breakdown) {
        const canvas = els.jobPieChart;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const items = [
          { key: 'Uptime', value: breakdown.uptime, color: '#22a06b' },
          { key: 'Downtime ReadyNoProductFeed', value: breakdown.readyDowntime, color: '#f6c547' },
          { key: 'Overige downtime', value: breakdown.otherDowntime, color: '#e34b4b' }
        ];
        const total = items.reduce((s, i) => s + i.value, 0);
        if (total <= 0) return items;

        let start = -Math.PI / 2;
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = 82;

        for (const item of items) {
          const angle = (item.value / total) * Math.PI * 2;
          if (angle <= 0) continue;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.arc(cx, cy, radius, start, start + angle);
          ctx.closePath();
          ctx.fillStyle = item.color;
          ctx.fill();
          start += angle;
        }

        ctx.beginPath();
        ctx.arc(cx, cy, 38, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        return items;
      }

      function renderJobSideDetail(job) {
        if (!job) {
          els.jobDetailTitle.textContent = 'Klik op een job in de tabel.';
          els.jobPieLegend.innerHTML = '';
          els.jobDowntimeList.innerHTML = '<li class="muted">Geen job geselecteerd.</li>';
          const ctx = els.jobPieChart.getContext('2d');
          ctx.clearRect(0, 0, els.jobPieChart.width, els.jobPieChart.height);
          return;
        }

        const breakdown = getDowntimeBreakdownForDetail(job);
        const parts = drawJobPieChart(breakdown);
        const total = breakdown.uptime + breakdown.readyDowntime + breakdown.otherDowntime;

        els.jobDetailTitle.innerHTML = `<strong>${job.jobName}</strong><br><span class="muted">Totale jobduur: ${formatDuration(total)}</span>`;

        els.jobPieLegend.innerHTML = parts.map((part) => {
          const pct = total === 0 ? 0 : (part.value / total) * 100;
          return `<div class="legend-item"><span><span class="dot" style="background:${part.color}"></span>${part.key}</span><strong>${formatDuration(part.value)} (${pct.toFixed(1)}%)</strong></div>`;
        }).join('');

        const reasonEntries = Array.from(job.timeline.reasons.entries()).sort((a, b) => b[1] - a[1]);
        const listedReasons = [...reasonEntries];
        const missing = Math.max(0, breakdown.otherDowntime - reasonEntries
          .filter(([reason]) => reason.toLowerCase() !== 'readynoproductfeed')
          .reduce((sum, [, sec]) => sum + sec, 0));

        if (missing > 0) {
          listedReasons.push(['Onbekende downtime (ontbreekt in timeline)', missing]);
        }

        if (listedReasons.length === 0) {
          els.jobDowntimeList.innerHTML = '<li class="muted">Geen downtime regels in timeline voor deze job.</li>';
          return;
        }

        els.jobDowntimeList.innerHTML = listedReasons
          .sort((a, b) => b[1] - a[1])
          .map(([reason, sec]) => `<li>${reason}: <strong>${formatDuration(sec)}</strong></li>`)
          .join('');
      }

      function renderCrossSection(jobName) {
        const job = aggregateByJob().find((j) => j.jobName === jobName);
        if (!job) {
          els.selectedJobStats.innerHTML = '<p class="muted">Geen job geselecteerd.</p>';
          els.reasonBreakdown.innerHTML = '';
          return;
        }

        const t = job.timeline;
        const s = job.stats;
        const primary = getPrimaryTimes(job);
        const primaryEff =
          primary.uptimeSeconds + primary.downtimeSeconds === 0
            ? 0
            : (primary.uptimeSeconds / (primary.uptimeSeconds + primary.downtimeSeconds)) * 100;
        const timelineEff = t.uptimeSeconds + t.downtimeSeconds === 0 ? 0 : (t.uptimeSeconds / (t.uptimeSeconds + t.downtimeSeconds)) * 100;
        const jobStatsEff = s.totalTimeSeconds === 0 ? 0 : (s.uptimeSeconds / s.totalTimeSeconds) * 100;
        const prodRate = s.productionRateWeight === 0 ? 0 : s.productionRateWeightedSum / s.productionRateWeight;

        els.selectedJobStats.innerHTML = `
          <div class="cards">
            <article class="card"><span>Job</span><strong>${job.jobName}</strong></article>
            <article class="card"><span>Periode</span><strong>${formatDateTime(job.firstSeenTs)} → ${formatDateTime(job.lastSeenTs)}</strong></article>
            <article class="card"><span>Efficiëntie (JobStatistics primair)</span><strong>${primaryEff.toFixed(2)}%</strong></article>
            <article class="card"><span>Efficiëntie (timeline detail)</span><strong>${timelineEff.toFixed(2)}%</strong></article>
            <article class="card"><span>JobStatistics uptime-rate</span><strong>${jobStatsEff.toFixed(2)}%</strong></article>
            <article class="card"><span>Uptime/Downtime (primair)</span><strong>${formatDuration(primary.uptimeSeconds)} / ${formatDuration(primary.downtimeSeconds)}</strong></article>
            <article class="card"><span>Total Pieces</span><strong>${s.totalPieces}</strong></article>
            <article class="card"><span>Good/Reject</span><strong>${s.goodPieces} / ${s.rejectPieces}</strong></article>
            <article class="card"><span>Production Rate</span><strong>${prodRate.toFixed(2)}</strong></article>
            <article class="card"><span>Snelheid tijdens uptime (good/uur)</span><strong>${getGoodPerUptimeHour(job).toFixed(2)}</strong></article>
            <article class="card"><span>Shift</span><strong>${s.lastShiftName || '-'}</strong></article>
            <article class="card"><span>Uptime/Unscheduled DT (JobStatistics)</span><strong>${formatDuration(s.uptimeSeconds)} / ${formatDuration(s.unscheduledDowntimeSeconds)}</strong></article>
          </div>
        `;

        const reasons = Array.from(t.reasons.entries()).sort((a,b)=>b[1]-a[1]);
        if (reasons.length === 0) {
          els.reasonBreakdown.innerHTML = '<p class="muted">Geen downtime oorzaken in timeline voor deze job.</p>';
          return;
        }

        els.reasonBreakdown.innerHTML = reasons.map(([reason, sec]) => {
          const pct = t.downtimeSeconds === 0 ? 0 : (sec / t.downtimeSeconds) * 100;
          return `<div class="reason-row"><div><div>${reason} (${formatDuration(sec)})</div><div class="progress"><span style="width:${pct.toFixed(2)}%"></span></div></div><strong>${pct.toFixed(1)}%</strong></div>`;
        }).join('');
      }

      render();
    </script>
  </body>
</html>
